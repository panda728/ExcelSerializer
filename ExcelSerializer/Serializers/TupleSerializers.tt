﻿<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Buffers" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Buffers" #>
<#@ output extension=".cs" #>
<#
    const int MaxTupleCount = 8;
    string BuildTypeParameter(int i) => "T" + ((i == 8) ? "Rest" : i.ToString());
    string BuildTypeParameters(int i) => string.Join(", ", Enumerable.Range(1, i).Select(BuildTypeParameter));
    string BuildGetItemProperty(int i) => ((i == 8) ? "Rest" : $"Item{i}");
    string BuildTitleParameter(int i) => ((i == 1) ? "name" : @$"$""{{name}}{i}""");
    string BuildTitleParameters(int i) => string.Join(", ", Enumerable.Range(1, i).Select(BuildTitleParameter));
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY `Serializers/TupleSerializers.tt`. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
using System.Buffers;
namespace ExcelSerializerLib.Serializers
{
<# for(var i = 1; i <= MaxTupleCount; i++) { #>
    public sealed class TupleExcelSerializer<<#= BuildTypeParameters(i) #>> : IExcelSerializer<Tuple<<#= BuildTypeParameters(i) #>>>
<# if(i == MaxTupleCount) { #>
        where TRest : notnull
<# } #>
    {
		public void WriteTitle(ref ExcelFormatter formatter, IBufferWriter<byte> writer, Tuple<<#= BuildTypeParameters(i) #>> value, ExcelSerializerOptions options, string name = "value"){
            formatter.EnterAndValidate();
<# for(var j = 1; j <= i; j++) { #>
<# if(j != 1) { #>
<# } #>
            options.GetRequiredSerializer<<#= BuildTypeParameter(j) #>>().WriteTitle(ref formatter, writer, value.<#= BuildGetItemProperty(j) #>, options, <#= BuildTitleParameter(j) #>);
<# } #>
            formatter.Exit();
        }
        public void Serialize(ref ExcelFormatter formatter, IBufferWriter<byte> writer, Tuple<<#= BuildTypeParameters(i) #>> value, ExcelSerializerOptions options)
        {
            if (value == null) {
                formatter.WriteEmpty(writer);
                return;
            }
            formatter.EnterAndValidate();
<# for(var j = 1; j <= i; j++) { #>
<# if(j != 1) { #>
<# } #>
            options.GetRequiredSerializer<<#= BuildTypeParameter(j) #>>().Serialize(ref formatter, writer, value.<#= BuildGetItemProperty(j) #>, options);
<# } #>
            formatter.Exit();
        }
    }

    public sealed class ValueTupleExcelSerializer<<#= BuildTypeParameters(i) #>> : IExcelSerializer<ValueTuple<<#= BuildTypeParameters(i) #>>>
<# if(i == MaxTupleCount) { #>
        where TRest : struct
<# } #>
    {
		public void WriteTitle(ref ExcelFormatter formatter, IBufferWriter<byte> writer, ValueTuple<<#= BuildTypeParameters(i) #>> value, ExcelSerializerOptions options, string name = "value"){
        {
            formatter.EnterAndValidate();
<# for(var j = 1; j <= i; j++) { #>
<# if(j != 1) { #>
<# } #>
            options.GetRequiredSerializer<<#= BuildTypeParameter(j) #>>().WriteTitle(ref formatter, writer, value.<#= BuildGetItemProperty(j) #>, options, <#= BuildTitleParameter(j) #>);
<# } #>
            formatter.Exit();
        }
        }
        public void Serialize(ref ExcelFormatter formatter, IBufferWriter<byte> writer, ValueTuple<<#= BuildTypeParameters(i) #>> value, ExcelSerializerOptions options)
        {
            formatter.EnterAndValidate();
<# for(var j = 1; j <= i; j++) { #>
<# if(j != 1) { #>
<# } #>
            options.GetRequiredSerializer<<#= BuildTypeParameter(j) #>>().Serialize(ref formatter, writer, value.<#= BuildGetItemProperty(j) #>, options);
<# } #>
            formatter.Exit();
        }
    }

<# } #>

    internal static class TupleExcelSerializer
    {
        internal static Type GetTupleExcelSerializerType(int i)
        {
            switch (i)
            {
<# for(var i = 1; i <= MaxTupleCount; i++) { #>
                case <#= i #>:
                    return typeof(TupleExcelSerializer<<#= new string(',', i - 1) #>>);
<# } #>
                default:
                    break;
            }

            throw new InvalidOperationException($"TupleExcelSerializer<T1...T{i}> is not found.");
        }

        internal static Type GetValueTupleExcelSerializerType(int i)
        {
            switch (i)
            {
<# for(var i = 1; i <= MaxTupleCount; i++) { #>
                case <#= i #>:
                    return typeof(ValueTupleExcelSerializer<<#= new string(',', i - 1) #>>);
<# } #>
                default:
                    break;
            }

            throw new InvalidOperationException($"ValueTupleExcelSerializer<T1...T{i}> is not found.");
        }
    }
}